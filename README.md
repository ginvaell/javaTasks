1. Брагина Наталья Дмитриевна
2. Интерфейс содержит только объявления методов и константы (final static поля), тогда как абстракный класс может содержать поля, методы с реализацией (в том числе и приватные). Начиная с Java 8 интерфейсы могут содержать реализацию методов по умолчанию, что делает их похожими на интерфейсы, однако ограничение на поля и приватные методы остаются.
3. System.gc()
4. Тогда, когда требуется вызвать метод, не объявленный в супер классе у объекта, объявленноготчерез ссылку на супер класс. В качестве примера можно привести реализацию метода equals(Object o). удостоверившись, что переданный обект подходящего типа, мы приводим его к этому типу, а затем уже сравниваем нужные поля.
5. Конструкторы не возвращают значений, вызывваются для создания объекта. Если в конструкторе произошло исключение, обънект создан не будет.
6. Да. Это часто применяют для инициализации нескольких полей класса. Сначала пишут конструктор с наибольшим числом параметров, затем прочие, с меньшим числом параметров, в теле которых вызываются уже написанные конструкторы со значениями по умолчанию для полей, не вошедших в список параметров.
7. JDK - Java Development Kit содержит набор библиотек Java, компилятор и виртуальную машину, а так же ряд утилит для разработки. JRE - Java Runtime Invironment содержит виртуальную машину и набор библиотек.
8. Имеет. FileNotFoundException - подкласс IOExceptipon, следовательно если IOExceptipon перехватывать первым, то FileNotFoundException также будет перехвачен в этом блоке, и следующий блок, перехватывающий FileNotFoundException будет недостижим.
9. Да. Они так же будут иметь доступ ко всем полям внешнего класса.
10. Через ключевое слово super, которое содержит ссылку на объект суперкласса.
11. Очередь - список, добавление элементов в котором идет с конца, а выборка сначала. Стек - список, добавление и выборка элементов в котором идет с конца.
12. По статистике большинство объектов в Java становятся ненужными практически сразу после их создания и лишь немногие остаются живы на протяжении долгого времени. По этой причине JVM делит память на две неравные части, в одной (меньшей) хранит новые объекты - Joung generation, в другой старые объекты - Old generation. Сборка мусора в первой части осуществляется гораздо бюыстрее. Объект переходит в Old generation, если он пережил хотя бы один цикл сборки мусора.
13. Listener
14. Никакой, видимость на уровне пакета задается по умолчанию
15. Статический внутренний (вложенный) класс для получения доступа к нестатическим полям внешнего класса должен создать объект этого класса. К публичному вложенному классу можно обратится извне конструкцией ИмяВнешнегоКласса.ИмяВложенногоКласса . Вложенный класс нельзя создать внутри методв или блока.
16. Нет
17. Примитивные типы: byte, short, int, long, float, double, boolean, char. Примитивные типы хранятся в стеке. Ссылочные типы - оъекты, хранятся в куче, а ссылки на них хранятся в стеке.
18. Термин переопределение означает, что в классе наследнике определен метод с той же сигнатуров, что и в базовом классе. Если создать объект производного класса через ссылку на предка и вызвыать переопределенный метод, то будет вызван метод потомка - это основа полиморфизма. Термин перегрузка означает, что в классе определено несколько методов с одинаковым названием, но разной сигнатурой. В таком случае решение, какой именно метод нужно вызвать в конкретной ситуации будет приниматься в зависимости от типа и количества переданных аргументов.
19. Итератор - это паттерн. Итератор предназначен для переборки, вставки и удаления элементов некоторого списка.
20. Exeption (наследуется от Throwable) - проверяемые исключительные ситуации (обязательно должны быть отловлены или прокинуты дальше), RuntimeExeption (наследуется от Exeption) - непроверяемые исключительные ситуации (их отлавливать не обязательно), Error  (наследуется от Throwable) - ошибки (отлавливать не обязательно, в большинстве случаев бесполезно).
21. Ключевое слово throws добавляется к сигнатуре метода вместе с типом исключения и свидетельствует о том, что данный метод может бросить исключение указанного типа, ключевое слово throw говорит, что в данном месте нужно бросить исключение, указанное в throws, или его потомка. После того как исключение будет брошено, выполнение метода прекратится.
22. Блок finally выполнится плосле блоков try и catch не зависимо от того, было ли брошено исключение. Это необходимо, например, для закрытия ресурсов. Так же если внутри метода написать return в блоке try, а затем еще какой-то код в блоке finally, то этот код так же выполнится.
23.finalize - инструкция сборщику мусора, которая говорит, что перед тем, как объект будет уничтожен, необходимо выполнить еще некоторые дейсвия. Если у уничтожаемого объекта присутсвует finalize, то он отправляется в специальное место памяти, где будет ждать файналлизатора. Проблема заключается в том, что до того, как файналлизатор будет вызван, программа может прекратить работу, кроме того в условии больших нагрузок finalize так же скорее всего вызван не будет, поэтому не стоит воспринимать finalize как деструктор. В finalize как правило прописывают закрытие ресурсов на тот случай если пользователь забыл сделать это самостоятельно.
24. Внутринние классы - члены: имеют доступ ко всем полям внешнего класса; вложенные (статические внутренние): имеют доступ ко всем статическим полям внешнего класса, для доступа к нестатичнским полям должны создавать объект внешнего класса; локальные (внутренние классы, объявленные внутри метода или блока): имеют доступ еще и к локальным переменным метода или блока, не могут содержать статических объявлений, кроме констант, не могут иметь модификаторы доступа; анонимные: имеют те же ограничения, что и локальные классы + нельзя определять конструктор (аргументы переданные в скобках при объявлении анонимного класса будут использованы для передачи в конструктор базового класса), используются если: тело класса является очень коротким, нужен только один экземпляр класса, класс используется в месте его создания или сразу после него, имя класса не важно и не облегчает понимание кода.
