1. ФИО  
Брагина Наталья Дмитриевна
2. Какова разница между абстрактным классом и интерфейсом?  
Интерфейс содержит только объявления методов и константы (final static поля), тогда как абстрактный класс может содержать любые поля и  методы с реализацией (в том числе и приватные). Начиная с Java 8 интерфейсы могут содержать реализацию методов по умолчанию (это дает возможность добавлять новые методы в старые интерфейсы), что делает их похожими на интерфейсы, однако ограничение на поля и приватные методы остаются. Все методы интерфейса public abstract по умолчанию, а поля public static final.
3. Как «насильно» вызвать сборку мусора?  
System.gc() не гарантировано, что сборщик мусора дейсвительно будет вызван
4. Когда требуется явное приведение классов?  
Тогда, когда требуется вызвать метод, не объявленный в супер-классе у объекта, объявленного через ссылку на-супер класс. В качестве примера можно привести реализацию метода equals(Object o). удостоверившись, что переданный обект подходящего типа, мы приводим его к этому типу, а затем уже сравниваем нужные поля.
5. Чем конструкторы отличаются от других методов?  
Конструкторы не возвращают значений, вызывваются для создания объекта. Если в конструкторе произошло исключение, объект создан не будет.
6. Можно ли вызывать конструкторы один из другого, если их в классе несколько?  
Да. Это часто применяют для инициализации нескольких полей класса. Сначала пишут конструктор с наибольшим числом параметров, затем прочие, с меньшим числом параметров, в теле которых вызываются уже написанные конструкторы со значениями по умолчанию для полей, не вошедших в список параметров.
7. В чем разница между JDK и JRE?  
JDK - Java Development Kit содержит набор библиотек Java, компилятор и виртуальную машину, а так же ряд утилит для разработки. JRE - Java Runtime Environment содержит виртуальную машину и набор библиотек.
8. Имеет ли значение в каком порядке перехватывать исключения FileNotFoundException и IOExceptipon?  
Имеет. FileNotFoundException - подкласс IOException, следовательно если IOException перехватывать первым, то FileNotFoundException также будет перехвачен в этом блоке, и следующий блок, перехватывающий FileNotFoundException будет недостижим.
9. Могут ли внутренние классы, описанные внутри метода, иметь доступ к локальным переменным этого метода?  
Да. Они так же будут иметь доступ ко всем полям внешнего класса.
10. Как подкласс может обратиться к методу или конструктору из суперкласса?  
Через ключевое слово super, которое содержит ссылку на объект суперкласса.
11. В чем разница между очередью и стеком?  
Очередь - список, добавление элементов в котором идет с конца, а выборка сначала. Стек - список, добавление и выборка элементов в котором идет с конца.
12. Что вам приходит в голову, когда вы слышите о новом поколении (young generation) в Java?  
По статистике большинство объектов в Java становятся ненужными практически сразу после их создания и лишь немногие остаются живы на протяжении долгого времени. По этой причине JVM делит память на две неравные части, в одной (меньшей) хранит новые объекты - Young generation, в другой старые объекты - Old generation. Сборка мусора в первой части осуществляется гораздо быстрее. Объект переходит в Old generation, если он пережил хотя бы один цикл сборки мусора.
13. Есть два класса: A и B. Класс B должен информировать класс A когда случается некое важное событие. Какой design-pattern вы должны реализовать?  
Слушатель
14. Какой модификатор доступа надо указать в классе, чтобы доступ к нему имели только классы из того же пакета?  
Никакой, видимость на уровне пакета задается по умолчанию
15. Чем отличается статический внутренний класс от просто внутреннего класса?  
Статический внутренний (вложенный) класс для получения доступа к не статическим полям внешнего класса должен создать объект этого класса. К публичному вложенному классу можно обратится извне конструкцией ИмяВнешнегоКласса.ИмяВложенногоКласса . Вложенный класс нельзя создать внутри метода или блока.
16. можно ли обратиться к не-статической переменной из статического метода?  
Нет
17. какие типы данных есть в Java?  
Примитивные типы: byte, short, int, long, float, double, boolean, char. Примитивные типы хранятся в стеке. Ссылочные типы - оъекты, хранятся в куче, а ссылки на них хранятся в стеке.
18. Чем отличаются переопределение (Override) и перегрузка (Overload)  
Термин переопределение означает, что в классе наследнике определен метод с той же сигнатуров, что и в базовом классе. Если создать объект производного класса через ссылку на предка и вызвыать переопределенный метод, то будет вызван метод потомка - это основа полиморфизма. Термин перегрузка означает, что в классе определено несколько методов с одинаковым названием, но разной сигнатурой. В таком случае решение, какой именно метод нужно вызвать в конкретной ситуации будет приниматься в зависимости от типа и количества переданных аргументов.
19. Что такое итератор?  
Итератор - это паттерн. Итератор предназначен для переборки, вставки и удаления элементов списка.
20. Перечислите основные категории исключительных ситуаций  
Exeption (наследуется от Throwable) - проверяемые исключительные ситуации (обязательно должны быть отловлены или прокинуты дальше), RuntimeExeption (наследуется от Exeption) - непроверяемые исключительные ситуации (их отлавливать не обязательно), Error  (наследуется от Throwable) - ошибки (отлавливать не обязательно, в большинстве случаев бесполезно).
21. Какая разница между throw и throws?  
Ключевое слово throws добавляется к сигнатуре метода вместе с типом исключения и свидетельствует о том, что данный метод может бросить исключение указанного типа, ключевое слово throw говорит, что в данном месте нужно бросить исключение, указанное в throws, или его потомка. После того как исключение будет брошено, выполнение метода прекратится.
22. Зачем нужен блок finally?  
Блок finally выполнится плосле блоков try и catch не зависимо от того, было ли брошено исключение. Это необходимо, например, для закрытия ресурсов. Так же если внутри метода написать return в блоке try, а затем еще какой-то код в блоке finally, то этот код так же выполнится.
23. Что такое finalize?  
finalize - инструкция сборщику мусора, которая говорит, что перед тем, как объект будет уничтожен, необходимо выполнить еще некоторые дейсвия. Если у уничтожаемого объекта присутсвует finalize, то он помещается в очередь, где будет ждать поток финализатор. Проблема заключается в том, что до того, как финализатор будет вызван, программа может прекратить работу, кроме того в условии больших нагрузок finalize так же скорее всего вызван не будет, поэтому не стоит воспринимать finalize как деструктор. В finalize как правило прописывают закрытие ресурсов на тот случай если пользователь забыл сделать это самостоятельно.
24. Перечислите все виды внутренних классов  
Внутринние классы - члены: имеют доступ ко всем полям внешнего класса; вложенные (статические внутренние): имеют доступ ко всем статическим полям внешнего класса, для доступа к нестатичнским полям должны создавать объект внешнего класса; локальные (внутренние классы, объявленные внутри метода или блока): имеют доступ еще и к локальным переменным метода или блока, не могут содержать статических объявлений, кроме констант, не могут иметь модификаторы доступа; анонимные: имеют те же ограничения, что и локальные классы + нельзя определять конструктор (аргументы переданные в скобках при объявлении анонимного класса будут использованы для передачи в конструктор базового класса), используются если: тело класса является очень коротким, нужен только один экземпляр класса, класс используется в месте его создания или сразу после него, имя класса не важно и не облегчает понимание кода.
